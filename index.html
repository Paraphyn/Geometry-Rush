<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circle Shooter (Refactored)</title>
  <style>
    body, html {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #000;
    }
    .ui {
      position: absolute;
      color: white;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      pointer-events: none;
    }
    .enemies { top: 20px; left: 20px; font-size: 25px; }
    .timer { top: 20px; left: 50%; transform: translateX(-50%); font-size: 50px; }
    .score { top: 20px; right: 20px; font-size: 25px; }
    .controls { bottom: 20px; left: 20px; font-size: 20px; opacity: 0.8; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="ui enemies">Enemies: <span id="enemies">0</span></div>
  <div class="ui timer"><span id="timer">00:00</span></div>
  <div class="ui score">Score: <span id="score">0</span></div>
  <div class="ui controls">WASD to move | Mouse to aim | Hold left click to shoot | ESC to pause</div>

  <script>
    // === CANVAS SETUP ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // === CONSTANTS ===
    const GRID_SIZE = 40;
    const ENEMY_TYPES = {
      square:   { health: 200, speed: 2,   size: 24, points: 5 },
      triangle: { health: 50,  speed: 4,   size: 12, points: 10 },
      octagon:  { health: 1000,speed: 0.8, size: 31, points: 50 }
    };

    // === INPUT ===
    const input = {
      keys: {},
      mouse: { x: 0, y: 0, down: false },
      lastKeyTime: {},
      preventSpam(key, delay = 100) {
        const now = Date.now();
        if (this.lastKeyTime[key] && now - this.lastKeyTime[key] < delay) return false;
        this.lastKeyTime[key] = now;
        return true;
      }
    };

    // === GAME STATE ===
    let game = {};
    function createGameState() {
      return {
        player: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 15,
          speed: 5,
          health: 100,
          maxHealth: 100,
          damageFlash: 0
        },
        mouse: { x: canvas.width / 2, y: canvas.height / 2 },
        bullets: [],
        enemies: [],
        explosions: [],
        bulletTrails: [],
        hitEffects: [],
        damageLabels: [],
        enemyDamageLabels: [],
        score: 0,
        startTime: Date.now(),
        lastEnemySpawn: 0,
        enemySpawnRate: 2000,
        mouseDown: false,
        lastShot: 0,
        shootDelay: 250,
        gameOver: false,
        paused: false,
        pauseTime: 0,
        gameOverTime: 0
      };
    }
    function resetGame() {
      game = createGameState();
    }
    resetGame();

    // === UTILITY FUNCTIONS ===
    const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1, y2-y1);
    const formatTime = ms => {
      const sec = Math.floor(ms/1000), m = Math.floor(sec/60), s = sec%60;
      return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    };

    // === INPUT HANDLERS ===
    function handleKey(e, isDown) {
      const moveKeys = {
        KeyW:'w', ArrowUp:'w',
        KeyS:'s', ArrowDown:'s',
        KeyA:'a', ArrowLeft:'a',
        KeyD:'d', ArrowRight:'d'
      };
      if (moveKeys[e.code]) {
        e.preventDefault();
        input.keys[moveKeys[e.code]] = isDown;
      }
    }

    document.addEventListener('keydown', e => {
      if (["Escape","Space","KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
      
      if (e.key==='Escape' && input.preventSpam('esc',200)) {
        if (!game.gameOver) {
          game.paused = !game.paused;
          if (game.paused) game.pauseTime = Date.now();
          else game.startTime += Date.now()-game.pauseTime;
        }
      }
      if (e.code==='Space' && game.gameOver && input.preventSpam('space',300)) resetGame();
      if (!game.gameOver && !game.paused) handleKey(e,true);
    });

    document.addEventListener('keyup', e => handleKey(e,false));

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      game.mouse.x = e.clientX - rect.left;
      game.mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', e => {
      if (e.button!==0) return;
      if (game.gameOver) return; // TODO: restart button click check
      if (!game.paused) {
        input.mouse.down = true;
        game.mouseDown = true;
        shoot();
      }
    });
    canvas.addEventListener('mouseup', e => { if (e.button===0) {input.mouse.down=false;game.mouseDown=false;} });
    window.addEventListener('blur', ()=>{input.keys={};input.mouse.down=false;game.mouseDown=false;});

    // === CORE GAME FUNCTIONS (SPAWN, SHOOT, UPDATE, DRAW) ===

    function shoot() {
      const now = Date.now();
      if (now - game.lastShot < game.shootDelay) return;
      const dx = game.mouse.x - game.player.x;
      const dy = game.mouse.y - game.player.y;
      const d = Math.hypot(dx,dy);
      if (d>0) {
        game.bullets.push({ x:game.player.x, y:game.player.y, dx:(dx/d)*8, dy:(dy/d)*8, radius:3, life:100 });
        game.lastShot = now;
      }
    }

    function spawnEnemy() {
      const side = Math.floor(Math.random()*4), margin=30;
      let x,y;
      if(side===0){x=Math.random()*canvas.width;y=-margin;}
      if(side===1){x=canvas.width+margin;y=Math.random()*canvas.height;}
      if(side===2){x=Math.random()*canvas.width;y=canvas.height+margin;}
      if(side===3){x=-margin;y=Math.random()*canvas.height;}
      const types=Object.keys(ENEMY_TYPES);
      const type=types[Math.floor(Math.random()*types.length)];
      const cfg=ENEMY_TYPES[type];
      game.enemies.push({ x,y,type, radius:cfg.size, speed:cfg.speed, health:cfg.health, maxHealth:cfg.health, points:cfg.points, damage:cfg.damage||25, damageFlash:0 });
    }

    function update() {
      if(game.gameOver||game.paused) return;

      // Movement
      const p=game.player;
      let nx=p.x,ny=p.y;
      if(input.keys.w) ny-=p.speed;
      if(input.keys.s) ny+=p.speed;
      if(input.keys.a) nx-=p.speed;
      if(input.keys.d) nx+=p.speed;
      p.x=Math.max(p.radius,Math.min(canvas.width-p.radius,nx));
      p.y=Math.max(p.radius,Math.min(canvas.height-p.radius,ny));

      // Shooting
      if(game.mouseDown) shoot();

      // Update bullets
      for(let i=game.bullets.length-1;i>=0;i--){
        const b=game.bullets[i];
        b.x+=b.dx;b.y+=b.dy;b.life--;
        if(b.life<=0||b.x<0||b.y<0||b.x>canvas.width||b.y>canvas.height) game.bullets.splice(i,1);
      }

      // Update enemies
      for(let i=game.enemies.length-1;i>=0;i--){
        const e=game.enemies[i];
        if(e.damageFlash>0) e.damageFlash--;
        const d=dist(p.x,p.y,e.x,e.y);
        if(d>0){e.x+=(p.x-e.x)/d*e.speed; e.y+=(p.y-e.y)/d*e.speed;}
        if(d<e.radius+p.radius){ // collision player
          p.health=Math.max(0,p.health-25);
          e.health=0; // enemy dies on contact
        }
        // Bullet collision
        for(let j=game.bullets.length-1;j>=0;j--){
          const b=game.bullets[j];
          if(dist(b.x,b.y,e.x,e.y)<b.radius+e.radius){
            e.health-=50;
            game.bullets.splice(j,1);
            if(e.health<=0){game.score+=e.points;}
            break;
          }
        }
        if(e.health<=0) game.enemies.splice(i,1);
      }

      // Spawn new enemies
      const now=performance.now();
      if(now-game.lastEnemySpawn>game.enemySpawnRate){
        spawnEnemy();
        game.lastEnemySpawn=now;
        game.enemySpawnRate=Math.max(500,game.enemySpawnRate*0.99);
      }

      if(p.health<=0) game.gameOver=true;
    }

    function drawGrid() {
      ctx.strokeStyle='rgba(255,255,255,0.1)';ctx.lineWidth=1;
      for(let x=0;x<=canvas.width;x+=GRID_SIZE){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
      for(let y=0;y<=canvas.height;y+=GRID_SIZE){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
    }

    function drawPlayer() {
      const p=game.player;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
      ctx.fillStyle=p.damageFlash>0?'#f00':'#fff';
      ctx.fill();
      ctx.strokeStyle='#ccc';ctx.lineWidth=2;ctx.stroke();
      ctx.fillStyle=p.health>60?'#0f0':p.health>30?'#fa0':'#f00';
      ctx.font='bold 16px Arial';ctx.textAlign='center';
      ctx.fillText(`HP:${p.health}`,p.x,p.y+p.radius+20);
      // aim line
      ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(game.mouse.x,game.mouse.y);
      ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.stroke();
    }

    function drawEnemies(){
      game.enemies.forEach(e=>{
        ctx.fillStyle=e.damageFlash>0?'#fff':'#f00';
        ctx.beginPath();ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);ctx.fill();
        if(e.maxHealth>50){ctx.fillStyle='rgba(255,0,0,0.7)';ctx.fillRect(e.x-e.radius,e.y-e.radius-10,(e.health/e.maxHealth)*e.radius*2,4);}
      });
    }

    function drawBullets(){
      ctx.fillStyle='#0ff';
      game.bullets.forEach(b=>{ctx.beginPath();ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);ctx.fill();});
    }

    function draw() {
      ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);
      drawGrid();
      drawPlayer();
      drawEnemies();
      drawBullets();

      if(game.paused){
        ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle='#fff';ctx.font='48px Arial';ctx.textAlign='center';ctx.fillText('PAUSED',canvas.width/2,canvas.height/2);
      }

      if(game.gameOver){
        ctx.fillStyle='rgba(0,0,0,0.9)';ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle='#f44';ctx.font='48px Arial';ctx.textAlign='center';ctx.fillText('GAME OVER',canvas.width/2,canvas.height/2-40);
        ctx.fillStyle='#fff';ctx.font='28px Arial';ctx.fillText(`Score: ${game.score}`,canvas.width/2,canvas.height/2);
        ctx.fillText('Press SPACE to restart',canvas.width/2,canvas.height/2+40);
      }
    }

    // === GAME LOOP ===
    function loop(){
      const t=game.gameOver?game.gameOverTime:game.paused?game.pauseTime:Date.now();
      const elapsed=t-game.startTime;
      if(!game.paused && !game.gameOver) update();
      draw();
      document.getElementById('score').textContent=game.score;
      document.getElementById('enemies').textContent=game.enemies.length;
      document.getElementById('timer').textContent=formatTime(elapsed);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
