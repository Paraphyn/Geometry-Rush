<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: Roboto, sans-serif;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }
        
        canvas {
            display: block;
            background: #000000;
            position: relative;
            z-index: 10;
        }
        
        .ui {
            position: absolute;
            color: white;
            font-weight: normal;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            z-index: 100;
            pointer-events: none;
        }
        
        body * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            background: #000000 !important;
        }
        
        .debug, .overlay, .watermark, .info, pre, code {
            display: none !important;
            visibility: hidden !important;
        }
        
        body::before, body::after {
            display: none !important;
        }
        
        script {
            display: none !important;
        }
        
        .stats { top: 20px; left: 20px; font-size: 25px; }
        .timer { top: 20px; left: 50%; transform: translateX(-50%); font-size: 40px; }
        .controls { bottom: 20px; left: 20px; font-size: 14px; opacity: 0.7; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="ui stats" id="stats">Kills: 0 | Score: 0</div>
    <div class="ui timer" id="timer">00:00</div>
    <div class="ui controls">WASD or Touch Joystick to Move | Mouse/Touch to Aim & Shoot | Hold Right Mouse for Railgun</div>

    <script>
        // Game configuration
        const CONFIG = {
            aimSprite: {
                type: 'crosshair',
                size: 20,
                color: '#00ffff',
                imageUrl: '',
                lineWidth: 2
            }
        };

        // Enemy configuration
        const ENEMY_TYPES = {
            square: { 
                health: 200, 
                speed: 4, 
                size: 30, 
                points: 5, 
                damage: 15,
                fillColor: '#ff0000',
                strokeColor: '#cc0000'
            },
            triangle: { 
                health: 50, 
                speed: 6.5, 
                size: 15, 
                points: 10, 
                damage: 25,
                fillColor: '#ff6666',
                strokeColor: '#cc3333'
            },
            octagon: { 
                health: 800, 
                speed: 1, 
                size: 50, 
                points: 50, 
                damage: 50,
                fillColor: '#990000',
                strokeColor: '#660000'
            }
        };

        // Joystick for touch movement
        class Joystick {
            constructor() {
                this.active = false;
                this.baseX = 0;
                this.baseY = 0;
                this.stickX = 0;
                this.stickY = 0;
                this.maxRadius = 50;
                this.touchId = null;
            }

            start(x, y, touchId) {
                this.active = true;
                this.baseX = x;
                this.baseY = y;
                this.stickX = x;
                this.stickY = y;
                this.touchId = touchId;
            }

            update(x, y) {
                const dx = x - this.baseX;
                const dy = y - this.baseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const max = this.maxRadius;
                if (dist > max) {
                    const scale = max / dist;
                    this.stickX = this.baseX + dx * scale;
                    this.stickY = this.baseY + dy * scale;
                } else {
                    this.stickX = x;
                    this.stickY = y;
                }
            }

            end() {
                this.active = false;
                this.touchId = null;
            }

            getDirection() {
                if (!this.active) return { x: 0, y: 0 };
                const dx = this.stickX - this.baseX;
                const dy = this.stickY - this.baseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 10) return { x: 0, y: 0 };
                return { x: dx / this.maxRadius, y: dy / this.maxRadius };
            }

            draw(ctx) {
                if (!this.active) return;
                ctx.beginPath();
                ctx.arc(this.baseX, this.baseY, this.maxRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.stickX, this.stickY, this.maxRadius / 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Input management
        class InputManager {
            constructor() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false, rightDown: false };
                this.lastKeyTime = {};
                this.joystick = new Joystick();
                this.shootTouchId = null;
                this.lastShot = 0;
            }

            preventSpam(key, delay = 100) {
                const now = Date.now();
                if (this.lastKeyTime[key] && now - this.lastKeyTime[key] < delay) return false;
                this.lastKeyTime[key] = now;
                return true;
            }

            clear() {
                this.keys = {};
                this.mouse.down = false;
                this.mouse.rightDown = false;
                this.lastKeyTime = {};
                this.joystick.end();
                this.shootTouchId = null;
                this.lastShot = 0;
            }
        }

        // Aim sprite
        class Aim {
            constructor(config) {
                this.x = 0;
                this.y = 0;
                this.config = config;
                this.image = null;
                if (config.type === 'image' && config.imageUrl) {
                    this.image = new Image();
                    this.image.src = config.imageUrl;
                }
            }

            update(x, y) {
                this.x = x;
                this.y = y;
            }

            draw(ctx) {
                if (this.config.type === 'image' && this.image && this.image.complete) {
                    ctx.drawImage(this.image, this.x - this.config.size / 2, this.y - this.config.size / 2, this.config.size, this.config.size);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.config.size / 2, this.y);
                    ctx.lineTo(this.x + this.config.size / 2, this.y);
                    ctx.moveTo(this.x, this.y - this.config.size / 2);
                    ctx.lineTo(this.x, this.y + this.config.size / 2);
                    ctx.strokeStyle = this.config.color;
                    ctx.lineWidth = this.config.lineWidth;
                    ctx.stroke();
                }
            }
        }

        // Player management
        class Player {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.health = 100;
                this.maxHealth = 100;
                this.score = 0;
                this.damageFlash = 0;
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                this.railgunCharge = 0;
                this.railgunMaxChargeTime = 5000;
                this.railgunParticles = [];
                this.blinkState = true;
                this.blinkFrame = 0;
                this.speed = 5;
            }

            move(keys, joystick, canvas) {
                let dx = 0, dy = 0;
                if (keys.w || keys.ArrowUp) dy -= 1;
                if (keys.s || keys.ArrowDown) dy += 1;
                if (keys.a || keys.ArrowLeft) dx -= 1;
                if (keys.d || keys.ArrowRight) dx += 1;
                const joystickDir = joystick.getDirection();
                dx += joystickDir.x;
                dy += joystickDir.y;
                const mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 0) {
                    dx = (dx / mag) * this.speed;
                    dy = (dy / mag) * this.speed;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x + dx));
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y + dy));
                }
            }

            update(input, effects, canvas) {
                if (this.damageFlash > 0) this.damageFlash--;
                if (this.invulnerable && this.invulnerabilityTime > 0) {
                    this.invulnerabilityTime--;
                    if (this.invulnerabilityTime <= 0) this.invulnerable = false;
                }
                this.health = Math.max(0, Math.min(this.maxHealth, Math.floor(this.health)));

                if (input.mouse.down && input.preventSpam('shoot', 100)) {
                    const dx = input.mouse.x - this.x;
                    const dy = input.mouse.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        const speed = 10;
                        effects.createBullet(this.id, this.x, this.y, (dx / dist) * speed, (dy / dist) * speed);
                        input.lastShot = Date.now();
                    }
                }

                if (input.mouse.rightDown) {
                    this.railgunCharge = Math.min(1, this.railgunCharge + (1000 / 60 / this.railgunMaxChargeTime));
                    if (this.railgunCharge === 1) {
                        this.blinkFrame = (this.blinkFrame + 1) % 30;
                        this.blinkState = this.blinkFrame < 15;
                    } else {
                        this.blinkState = true;
                        this.blinkFrame = 0;
                    }
                    if (this.railgunParticles.length < 2) {
                        const particleCount = Math.floor(Math.random() * 2) + 1;
                        for (let i = this.railgunParticles.length; i < particleCount; i++) {
                            effects.createRailgunParticle(this.x, this.y);
                        }
                    }
                    this.railgunParticles.forEach(p => p.update(this.x, this.y));
                } else if (this.railgunCharge > 0) {
                    effects.createRailgunBeam(this.x, this.y, input.mouse.x, input.mouse.y, canvas, this.railgunCharge);
                    this.railgunCharge = 0;
                    this.railgunParticles = [];
                    this.blinkState = true;
                    this.blinkFrame = 0;
                }
            }

            draw(ctx) {
                let fillColor = this.damageFlash > 0 ? '#ff0000' : this.invulnerable ? '#f0f0ff' : '#ffffff';
                let strokeColor = this.damageFlash > 0 ? '#cc0000' : this.invulnerable ? '#a0a0ff' : '#cccccc';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                const healthColor = this.health > 60 ? '#00ff00' : this.health > 30 ? '#ffaa00' : '#ff0000';
                ctx.fillStyle = healthColor;
                ctx.font = 'bold 18.75px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`HP: ${this.health}`, this.x, this.y + this.radius + 22);
            }
        }

        // Player bullet management
        class Bullet {
            constructor(id, x, y, dx, dy) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = 4;
                this.life = 100;
            }

            update(canvas, effects) {
                effects.createBulletTrail(this.x, this.y, '#00ffff');
                this.x += this.dx;
                this.y += this.dy;
                this.life--;
                return this.life > 0 && this.x >= 0 && this.x <= canvas.width && this.y >= 0 && this.y <= canvas.height;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#00ffff';
                ctx.fill();
                ctx.strokeStyle = '#00cccc';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Enemy bullet management
        class EnemyBullet {
            constructor(id, x, y, dx, dy) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = 6;
                this.life = 100;
            }

            update(canvas, effects) {
                effects.createBulletTrail(this.x, this.y, '#ffaa00');
                this.x += this.dx;
                this.y += this.dy;
                this.life--;
                return this.life > 0 && this.x >= 0 && this.x <= canvas.width && this.y >= 0 && this.y <= canvas.height;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ffaa00';
                ctx.fill();
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Triangle trail effect
        class TriangleTrail {
            constructor(x, y, size, opacity, fillColor) {
                this.x = x + (Math.random() - 0.5) * 2;
                this.y = y + (Math.random() - 0.5) * 2;
                this.size = size;
                this.opacity = opacity;
                this.fillColor = fillColor;
                this.life = 60;
                this.maxLife = 60;
            }

            update() {
                this.life--;
                this.opacity = (this.opacity * (this.life / this.maxLife));
                this.size *= 0.98;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.fillColor;
                ctx.beginPath();
                const h = this.size * 1.5;
                ctx.moveTo(this.x, this.y - h);
                ctx.lineTo(this.x - h * 0.866, this.y + h * 0.5);
                ctx.lineTo(this.x + h * 0.866, this.y + h * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // Railgun particle effect
        class RailgunParticle {
            constructor(x, y) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 150;
                this.x = x + Math.cos(angle) * distance;
                this.y = y + Math.sin(angle) * distance;
                this.size = 2 + Math.random() * 2;
                this.opacity = 0;
                this.maxOpacity = 0.7;
                this.life = 60;
                this.maxLife = 60;
                this.speed = 1.3 + Math.random() * 1.3;
            }

            update(playerX, playerY) {
                this.life--;
                this.opacity = this.maxOpacity * (1 - this.life / this.maxLife);
                const dx = playerX - this.x;
                const dy = playerY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.1) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Railgun beam effect
        class RailgunBeam {
            constructor(id, startX, startY, endX, endY, damage) {
                this.id = id;
                this.startX = startX;
                this.startY = startY;
                this.endX = endX;
                this.endY = endY;
                this.damage = damage;
                this.life = 60;
                this.maxLife = 60;
                this.opacity = 1.0;
                this.width = 8;
            }

            update() {
                this.life--;
                this.opacity = this.life / this.maxLife;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const gradient = ctx.createLinearGradient(this.startX, this.startY, this.endX, this.endY);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 1)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.2)');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.width;
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Enemy management
        class Enemy {
            constructor(id, x, y, type, config) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = config.size;
                this.health = config.health;
                this.maxHealth = config.health;
                this.fillColor = config.fillColor;
                this.strokeColor = config.strokeColor;
                this.damageFlash = 0;
                this.speed = config.speed;
                this.lastTrailTime = 0;
                this.lastShot = 0;
            }

            update(player, canvas, effects) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                if (this.type === 'triangle') {
                    const now = Date.now();
                    if (!this.lastTrailTime || now - this.lastTrailTime >= 50) {
                        const baseSize = ENEMY_TYPES[this.type].size * 0.8;
                        for (let i = 0; i < 5; i++) {
                            const size = baseSize * Math.pow(0.75, i);
                            const opacity = 0.5 - (i * 0.125);
                            effects.createTriangleTrail(this.x, this.y, size, opacity, ENEMY_TYPES[this.type].fillColor);
                        }
                        this.lastTrailTime = now;
                    }
                }
                if (Math.random() < 0.02 && Date.now() - this.lastShot > 1000) {
                    const speed = 5;
                    effects.createEnemyBullet(this.id, this.x, this.y, (dx / dist) * speed, (dy / dist) * speed);
                    this.lastShot = Date.now();
                }
            }

            draw(ctx) {
                const color = this.damageFlash > 0 ? '#ffffff' : this.fillColor;
                const stroke = this.damageFlash > 0 ? '#ffffff' : this.strokeColor;
                this.drawShape(ctx, this.x, this.y, this.type, this.radius, color, stroke);
                if (this.maxHealth > 50) {
                    const w = this.radius * 2, h = 4;
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.7)';
                    ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w, h);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w * (this.health / this.maxHealth), h);
                }
            }

            drawShape(ctx, x, y, type, size, fillColor, strokeColor) {
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                if (type === 'square') {
                    const s = size * 1.4;
                    ctx.fillRect(x - s/2, y - s/2, s, s);
                    ctx.strokeRect(x - s/2, y - s/2, s, s);
                } else if (type === 'triangle') {
                    ctx.beginPath();
                    const h = size * 1.5;
                    ctx.moveTo(x, y - h);
                    ctx.lineTo(x - h * 0.866, y + h * 0.5);
                    ctx.lineTo(x + h * 0.866, y + h * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (type === 'octagon') {
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        const px = x + size * Math.cos(angle);
                        const py = y + size * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }

        // Explosion effect
        class Explosion {
            constructor(x, y, type, size, fillColor, strokeColor) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.type = type;
                this.size = size * (0.3 + Math.random() * 0.2);
                this.fillColor = fillColor;
                this.strokeColor = strokeColor;
                this.opacity = 1;
                this.life = 30 + Math.random() * 20;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.dx *= 0.95;
                this.dy *= 0.95;
                this.life--;
                this.opacity = this.life / 50;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                Enemy.prototype.drawShape.call(this, ctx, this.x, this.y, this.type, this.size, this.fillColor, this.strokeColor);
                ctx.restore();
            }
        }

        // Bullet trail effect
        class BulletTrail {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = 5;
                this.opacity = 0.5;
                this.life = 6;
            }

            update() {
                this.life--;
                this.opacity = this.life / 6;
                this.size *= 0.95;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Hit effect
        class HitEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.size = 2 + Math.random() * 2;
                this.opacity = 1;
                this.life = 15 + Math.random() * 10;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.dx *= 0.9;
                this.dy *= 0.9;
                this.life--;
                this.opacity = this.life / 25;
                this.size *= 0.98;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Damage label effect
        class DamageLabel {
            constructor(x, y, damage, isPlayerDamage) {
                this.x = x;
                this.y = y;
                this.damage = Math.floor(damage);
                this.dx = isPlayerDamage ? (Math.random() - 0.5) * 4 : 0;
                this.dy = isPlayerDamage ? -2 - Math.random() * 1.5 : -0.5;
                this.gravity = isPlayerDamage ? 0 : 0;
                this.opacity = 1.0;
                this.life = isPlayerDamage ? 80 : 120;
                this.maxLife = this.life;
                this.scale = 0.8;
                this.isPlayerDamage = isPlayerDamage;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.dy += this.gravity;
                this.dx *= 0.99;
                this.life--;
                this.opacity = Math.max(0, this.life / this.maxLife);
                this.scale = 1.0 + (1 - this.opacity) * 0.2;
                return this.life > 0;
            }

            draw(ctx) {
                if (this.opacity > 0.01 && !isNaN(this.damage)) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    const fontSize = Math.floor(24 * this.scale);
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.fillStyle = this.isPlayerDamage ? '#ff0000' : '#00ffff';
                    const text = `-${this.damage}`;
                    ctx.strokeText(text, this.x, this.y);
                    ctx.fillText(text, this.x, this.y);
                    ctx.restore();
                }
            }
        }

        // Effects manager
        class EffectsManager {
            constructor() {
                this.bulletTrails = [];
                this.hitEffects = [];
                this.damageLabels = [];
                this.explosions = [];
                this.triangleTrails = [];
                this.railgunParticles = [];
                this.railgunBeams = [];
                this.bullets = [];
                this.enemyBullets = [];
            }

            createBullet(id, x, y, dx, dy) {
                this.bullets.push(new Bullet(id, x, y, dx, dy));
            }

            createEnemyBullet(id, x, y, dx, dy) {
                this.enemyBullets.push(new EnemyBullet(id, x, y, dx, dy));
            }

            createBulletTrail(x, y, color) {
                this.bulletTrails.push(new BulletTrail(x, y, color));
            }

            createHitEffect(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.hitEffects.push(new HitEffect(x, y));
                }
            }

            createDamageLabel(x, y, damage, isPlayerDamage) {
                if (isPlayerDamage) {
                    this.damageLabels = this.damageLabels.filter(label => label.life > 60);
                }
                this.damageLabels.push(new DamageLabel(x, y, damage, isPlayerDamage));
            }

            createExplosion(x, y, type, size) {
                const config = ENEMY_TYPES[type];
                const count = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    this.explosions.push(new Explosion(x, y, type, size, config.fillColor, config.strokeColor));
                }
            }

            createTriangleTrail(x, y, size, opacity, fillColor) {
                this.triangleTrails.push(new TriangleTrail(x, y, size, opacity, fillColor));
            }

            createRailgunParticle(playerX, playerY) {
                this.railgunParticles.push(new RailgunParticle(playerX, playerY));
            }

            createRailgunBeam(startX, startY, targetX, targetY, canvas, charge) {
                const dx = targetX - startX;
                const dy = targetY - startY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxDist = Math.max(canvas.width, canvas.height) * 2;
                const endX = startX + (dx / dist) * maxDist;
                const endY = startY + (dy / dist) * maxDist;
                const damage = charge <= 0.05 ? 5 : 5 + (300 - 5) * (charge - 0.05) / (1 - 0.05);
                this.railgunBeams.push(new RailgunBeam(`beam-${Date.now()}`, startX, startY, endX, endY, damage));
            }

            update(player, canvas) {
                this.bulletTrails = this.bulletTrails.filter(trail => trail.update());
                this.hitEffects = this.hitEffects.filter(effect => effect.update());
                this.damageLabels = this.damageLabels.filter(label => label.update());
                this.explosions = this.explosions.filter(explosion => explosion.update());
                this.triangleTrails = this.triangleTrails.filter(trail => trail.update());
                this.railgunParticles = this.railgunParticles.filter(p => p.update(player.x, player.y));
                this.railgunBeams = this.railgunBeams.filter(beam => beam.update());
                this.bullets = this.bullets.filter(bullet => bullet.update(canvas, this));
                this.enemyBullets = this.enemyBullets.filter(bullet => bullet.update(canvas, this));
            }

            draw(ctx, playerX, playerY) {
                this.bulletTrails.forEach(trail => trail.draw(ctx));
                this.hitEffects.forEach(effect => effect.draw(ctx));
                this.damageLabels.forEach(label => label.draw(ctx));
                this.explosions.forEach(explosion => explosion.draw(ctx));
                this.triangleTrails.forEach(trail => trail.draw(ctx));
                this.railgunParticles.forEach(particle => particle.draw(ctx));
                this.railgunBeams.forEach(beam => beam.draw(ctx));
                this.bullets.forEach(bullet => bullet.draw(ctx));
                this.enemyBullets.forEach(bullet => bullet.draw(ctx));
            }
        }

        // Main game class
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.input = new InputManager();
                this.aim = new Aim(CONFIG.aimSprite);
                this.setupCanvas();
                this.reset();
                this.setupEventListeners();
                this.lastSpawn = 0;
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            reset() {
                this.input.clear();
                this.player = new Player('local', this.canvas.width / 2, this.canvas.height / 2);
                this.enemies = [];
                this.effects = new EffectsManager();
                this.enemiesKilled = 0;
                this.startTime = Date.now();
                this.gameOver = false;
                this.paused = false;
                this.pauseTime = 0;
                this.gameOverTime = null;
                this.lastSpawn = 0;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    if (this.player && this.player.health === 100 && this.player.score === 0) {
                        this.player.x = this.canvas.width / 2;
                        this.player.y = this.canvas.height / 2;
                    }
                });

                document.addEventListener('keydown', e => {
                    const code = e.code;
                    if (['Escape', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(code)) {
                        e.preventDefault();
                    }
                    if (code === 'Escape' && this.input.preventSpam('Escape', 200)) {
                        if (!this.gameOver) {
                            this.paused = !this.paused;
                            if (this.paused) {
                                this.pauseTime = Date.now();
                                this.input.clear();
                            } else {
                                this.startTime += Date.now() - this.pauseTime;
                            }
                        }
                    }
                    if (code === 'Space' && this.input.preventSpam('Space', 300) && this.gameOver) {
                        this.reset();
                    }
                    if (!this.gameOver && !this.paused) {
                        const moveKeys = { 'KeyW': 'w', 'ArrowUp': 'w', 'KeyS': 's', 'ArrowDown': 's', 'KeyA': 'a', 'ArrowLeft': 'a', 'KeyD': 'd', 'ArrowRight': 'd' };
                        if (moveKeys[code]) this.input.keys[moveKeys[code]] = true;
                    }
                });

                document.addEventListener('keyup', e => {
                    const moveKeys = { 'KeyW': 'w', 'ArrowUp': 'w', 'KeyS': 's', 'ArrowDown': 's', 'KeyA': 'a', 'ArrowLeft': 'a', 'KeyD': 'd', 'ArrowRight': 'd' };
                    if (moveKeys[e.code]) {
                        e.preventDefault();
                        this.input.keys[moveKeys[e.code]] = false;
                    }
                });

                this.canvas.addEventListener('mousemove', e => {
                    if (this.gameOver) return;
                    const rect = this.canvas.getBoundingClientRect();
                    this.input.mouse.x = e.clientX - rect.left;
                    this.input.mouse.y = e.clientY - rect.top;
                });

                this.canvas.addEventListener('mousedown', e => {
                    if (this.gameOver) {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        const buttonX = this.canvas.width / 2;
                        const buttonY = this.canvas.height / 2 + 100;
                        const buttonWidth = 220;
                        const buttonHeight = 60;
                        if (mouseX >= buttonX - buttonWidth/2 && mouseX <= buttonX + buttonWidth/2 &&
                            mouseY >= buttonY - buttonHeight/2 && mouseY <= buttonY + buttonHeight/2) {
                            this.reset();
                        }
                        return;
                    }
                    if (!this.paused) {
                        if (e.button === 0) this.input.mouse.down = true;
                        else if (e.button === 2) this.input.mouse.rightDown = true;
                    }
                });

                this.canvas.addEventListener('mouseup', e => {
                    if (e.button === 0) this.input.mouse.down = false;
                    else if (e.button === 2) this.input.mouse.rightDown = false;
                });

                this.canvas.addEventListener('contextmenu', e => e.preventDefault());

                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    if (this.gameOver) {
                        const rect = this.canvas.getBoundingClientRect();
                        const buttonX = this.canvas.width / 2;
                        const buttonY = this.canvas.height / 2 + 100;
                        const buttonWidth = 220;
                        const buttonHeight = 60;
                        for (const touch of e.changedTouches) {
                            const touchX = touch.clientX - rect.left;
                            const touchY = touch.clientY - rect.top;
                            if (touchX >= buttonX - buttonWidth/2 && touchX <= buttonX + buttonWidth/2 &&
                                touchY >= buttonY - buttonHeight/2 && touchY <= buttonY + buttonHeight/2) {
                                this.reset();
                            }
                        }
                        return;
                    }
                    if (this.paused) {
                        this.paused = false;
                        this.startTime += Date.now() - this.pauseTime;
                        return;
                    }
                    for (const touch of e.changedTouches) {
                        const rect = this.canvas.getBoundingClientRect();
                        const touchX = touch.clientX - rect.left;
                        const touchY = touch.clientY - rect.top;
                        if (touchX < this.canvas.width / 2 && !this.input.joystick.active) {
                            this.input.joystick.start(touchX, touchY, touch.identifier);
                        } else if (touchX >= this.canvas.width / 2 && !this.input.shootTouchId) {
                            this.input.mouse.x = touchX;
                            this.input.mouse.y = touchY;
                            this.input.mouse.down = true;
                            this.input.shootTouchId = touch.identifier;
                        }
                    }
                });

                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    if (this.gameOver || this.paused) return;
                    for (const touch of e.changedTouches) {
                        const rect = this.canvas.getBoundingClientRect();
                        const touchX = touch.clientX - rect.left;
                        const touchY = touch.clientY - rect.top;
                        if (touch.identifier === this.input.joystick.touchId) {
                            this.input.joystick.update(touchX, touchY);
                        } else if (touch.identifier === this.input.shootTouchId) {
                            this.input.mouse.x = touchX;
                            this.input.mouse.y = touchY;
                        }
                    }
                });

                this.canvas.addEventListener('touchend', e => {
                    e.preventDefault();
                    for (const touch of e.changedTouches) {
                        if (touch.identifier === this.input.joystick.touchId) {
                            this.input.joystick.end();
                        } else if (touch.identifier === this.input.shootTouchId) {
                            this.input.mouse.down = false;
                            this.input.shootTouchId = null;
                        }
                    }
                });

                window.addEventListener('blur', () => this.input.clear());
                window.addEventListener('focus', () => this.input.clear());
            }

            update() {
                if (this.gameOver || this.paused) return;
                this.player.move(this.input.keys, this.input.joystick, this.canvas);
                this.player.update(this.input, this.effects, this.canvas);
                this.aim.update(this.input.mouse.x, this.input.mouse.y);

                // Spawn enemies
                if (Date.now() - this.lastSpawn > 2000) {
                    const types = ['square', 'triangle', 'octagon'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const config = ENEMY_TYPES[type];
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    if (side === 0) { x = Math.random() * this.canvas.width; y = -config.size; }
                    else if (side === 1) { x = Math.random() * this.canvas.width; y = this.canvas.height + config.size; }
                    else if (side === 2) { x = -config.size; y = Math.random() * this.canvas.height; }
                    else { x = this.canvas.width + config.size; y = Math.random() * this.canvas.height; }
                    this.enemies.push(new Enemy(`enemy-${Date.now()}-${Math.random()}`, x, y, type, config));
                    this.lastSpawn = Date.now();
                }

                // Update enemies
                this.enemies.forEach(enemy => enemy.update(this.player, this.canvas, this.effects));
                
                // Collision detection
                this.enemies = this.enemies.filter(enemy => {
                    if (enemy.damageFlash > 0) enemy.damageFlash--;
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (!this.player.invulnerable && dist < this.player.radius + enemy.radius) {
                        this.player.health -= ENEMY_TYPES[enemy.type].damage;
                        this.player.damageFlash = 20;
                        this.player.invulnerable = true;
                        this.invulnerabilityTime = 60;
                        this.effects.createDamageLabel(this.player.x, this.player.y - this.player.radius - 15, ENEMY_TYPES[enemy.type].damage, true);
                        enemy.health -= 1000; // Ensure enemy dies on contact
                        if (enemy.health <= 0) {
                            this.enemiesKilled += 1;
                            this.player.score += ENEMY_TYPES[enemy.type].points;
                            this.effects.createExplosion(enemy.x, enemy.y, enemy.type, enemy.radius);
                            return false;
                        }
                    }
                    for (const bullet of this.effects.bullets) {
                        const bdx = bullet.x - enemy.x;
                        const bdy = bullet.y - enemy.y;
                        const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
                        if (bdist < bullet.radius + enemy.radius) {
                            enemy.health -= 10;
                            enemy.damageFlash = 10;
                            bullet.life = 0;
                            this.effects.createHitEffect(bullet.x, bullet.y);
                            this.effects.createDamageLabel(enemy.x, enemy.y - enemy.radius - 15, 10, false);
                        }
                    }
                    for (const beam of this.effects.railgunBeams) {
                        const closestPoint = this.closestPointOnLine(beam.startX, beam.startY, beam.endX, beam.endY, enemy.x, enemy.y);
                        const bdx = closestPoint.x - enemy.x;
                        const bdy = closestPoint.y - enemy.y;
                        const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
                        if (bdist < enemy.radius) {
                            enemy.health -= beam.damage;
                            enemy.damageFlash = 10;
                            this.effects.createHitEffect(closestPoint.x, closestPoint.y);
                            this.effects.createDamageLabel(enemy.x, enemy.y - enemy.radius - 15, beam.damage, false);
                        }
                    }
                    if (enemy.health <= 0) {
                        this.enemiesKilled += 1;
                        this.player.score += ENEMY_TYPES[enemy.type].points;
                        this.effects.createExplosion(enemy.x, enemy.y, enemy.type, enemy.radius);
                        return false;
                    }
                    return true;
                });

                this.effects.enemyBullets.forEach(bullet => {
                    const dx = bullet.x - this.player.x;
                    const dy = bullet.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (!this.player.invulnerable && dist < bullet.radius + this.player.radius) {
                        this.player.health -= 10;
                        this.player.damageFlash = 20;
                        this.player.invulnerable = true;
                        this.player.invulnerabilityTime = 60;
                        bullet.life = 0;
                        this.effects.createDamageLabel(this.player.x, this.player.y - this.player.radius - 15, 10, true);
                    }
                });

                this.effects.update(this.player, this.canvas);

                if (this.player.health <= 0 && !this.gameOver) {
                    this.gameOver = true;
                    this.gameOverTime = Date.now();
                    this.input.clear();
                }
            }

            closestPointOnLine(x1, y1, x2, y2, px, py) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const lenSquared = dx * dx + dy * dy;
                if (lenSquared === 0) return { x: x1, y: y1 };
                const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lenSquared));
                return { x: x1 + t * dx, y: y1 + t * dy };
            }

            draw() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const gridSize = 40;
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x <= this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y <= this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                this.input.joystick.draw(this.ctx);

                this.effects.draw(this.ctx, this.player.x, this.player.y);

                if (this.player.railgunCharge > 0 && this.player.blinkState) {
                    const w = this.player.radius * 2;
                    const h = 4;
                    this.ctx.fillStyle = 'rgba(0, 100, 100, 0.7)';
                    this.ctx.fillRect(this.player.x - w/2, this.player.y - this.player.radius - 10, w, h);
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
                    this.ctx.fillRect(this.player.x - w/2, this.player.y - this.player.radius - 10, w * this.player.railgunCharge, h);
                }

                this.player.draw(this.ctx);
                this.enemies.forEach(enemy => enemy.draw(this.ctx));

                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y);
                this.ctx.lineTo(this.input.mouse.x, this.input.mouse.y);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
                this.aim.draw(this.ctx);

                if (this.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2 - 20);
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText('Press ESC or tap to continue', this.canvas.width / 2, this.canvas.height / 2 + 30);
                }

                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#ff4444';
                    this.ctx.font = '48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 60);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '28px Arial';
                    this.ctx.fillText(`Final Score: ${this.player.score}`, this.canvas.width / 2, this.canvas.height / 2 - 10);
                    this.ctx.fillText(`Survival Time: ${this.formatTime(this.gameOverTime - this.startTime)}`, this.canvas.width / 2, this.canvas.height / 2 + 30);

                    const buttonX = this.canvas.width / 2;
                    const buttonY = this.canvas.height / 2 + 100;
                    const buttonWidth = 220;
                    const buttonHeight = 60;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(buttonX - buttonWidth/2, buttonY - buttonHeight/2, buttonWidth, buttonHeight);
                    this.ctx.strokeStyle = '#cccccc';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(buttonX - buttonWidth/2, buttonY - buttonHeight/2, buttonWidth, buttonHeight);
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.font = '24px Arial';
                    this.ctx.fillText('PLAY AGAIN', buttonX, buttonY + 8);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText('Press SPACE or tap button to restart', buttonX, buttonY + 70);
                }

                document.getElementById('stats').textContent = `Kills: ${this.enemiesKilled} | Score: ${this.player.score}`;
                document.getElementById('timer').textContent = this.formatTime(this.gameOver ? this.gameOverTime - this.startTime : this.paused ? this.pauseTime - this.startTime : Date.now() - this.startTime);
            }

            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            loop(timestamp) {
                if (!this.paused && !this.gameOver) {
                    this.update();
                }
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }

            start() {
                requestAnimationFrame(t => this.loop(t));
            }
        }

        // Initialize and start the game
        const game = new Game();
        game.start();
    </script>
</body>
</html>
